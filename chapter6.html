<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chapter 6: Multimodal Synchronization - PhD Thesis</title>
    <link rel="stylesheet" href="styles.css">
    
    <!-- MathJax Configuration -->
    <script>
    MathJax = {
        tex: {
            inlineMath: [['$', '$'], ['\\(', '\\)']],
            displayMath: [['$$', '$$'], ['\\[', '\\]']],
            processEscapes: true,
            processEnvironments: true,
            tags: 'ams'
        },
        svg: {
            fontCache: 'global',
            displayAlign: 'center',
            displayIndent: '0em'
        },
        startup: {
            ready: () => {
                MathJax.startup.defaultReady();
                console.log('MathJax loaded for Chapter 6');
            }
        }
    };
    </script>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>
<body>
    <div class="progress-container">
        <div class="progress-bar"></div>
    </div>

    <header class="header">
        <div class="container">
            <h1>Chapter 6: Multimodal Synchronization</h1>
            <h2>Advanced Oscillator Models and Experimental Validation</h2>
            <div class="author">Sutirtha Chakraborty</div>
            <div class="university">Maynooth University</div>
        </div>
    </header>

    <nav class="nav">
        <div class="nav-container">
            <a href="index.html" class="nav-logo">PhD Thesis</a>
            <div class="nav-toggle">
                <span></span>
                <span></span>
                <span></span>
            </div>
            <ul>
                <li><a href="index.html">Home</a></li>
                <li><a href="chapter1.html">Ch 1: Introduction</a></li>
                <li><a href="chapter2.html">Ch 2: Literature</a></li>
                <li><a href="chapter3.html">Ch 3: Framework</a></li>
                <li><a href="chapter4.html">Ch 4: LeaderSTeM</a></li>
                <li><a href="chapter5.html">Ch 5: Visual Cues</a></li>
                <li><a href="chapter6.html">Ch 6: Multimodal</a></li>
                <li><a href="chapter7.html">Ch 7: Implementation</a></li>
                <li><a href="chapter8.html">Ch 8: Conclusion</a></li>
            </ul>
        </div>
    </nav>

    <!-- Breadcrumb Navigation -->
    <div class="container">
        <nav class="breadcrumb">
            <a href="index.html">Home</a>
            <span class="separator">‚Ä∫</span>
            <span class="current">Chapter 6: Multimodal Synchronization</span>
        </nav>
    </div>

    <div class="container">
        <div class="card" id="introduction">
            <h2>Introduction</h2>
            
            <div class="image-container">
                <img src="images/Multimodal/Fig1.png" alt="Multimodal Synchronization Overview">
                <div class="image-caption">Overview of multimodal synchronization framework integrating audio, visual, and leadership cues for comprehensive ensemble coordination</div>
            </div>

            <p>The convergence of audio analysis (Chapters 2-4), visual processing (Chapter 5), and leadership tracking has created a comprehensive foundation for understanding musical synchronization. This chapter presents the culmination of our research: a unified multimodal synchronization framework that integrates all sensory modalities and cognitive processes involved in ensemble musical performance.</p>

            <div class="quote">
                "True musical synchronization emerges not from any single sensory channel, but from the sophisticated integration of audio, visual, gestural, and leadership cues‚Äîa process that mirrors the complexity of human ensemble musicianship."
            </div>

            <h3>The Multimodal Challenge</h3>
            <p>While previous chapters have explored individual components of the synchronization puzzle, real-world musical performance requires the seamless integration of multiple information streams:</p>

            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 1.5rem; margin: 2rem 0;">
                <div style="background: #f0f9ff; padding: 1.5rem; border-radius: 8px; border-left: 4px solid #0ea5e9;">
                    <h4>üéµ Audio Processing</h4>
                    <p>Real-time analysis of harmonic content, <span class="tooltip">tempo<span class="tooltiptext">The speed or pace of music, usually measured in beats per minute (BPM)</span></span> variations, dynamic changes, and spectral features from the Cyborg Philharmonic framework.</p>
                </div>
                
                <div style="background: #f0fdf4; padding: 1.5rem; border-radius: 8px; border-left: 4px solid #22c55e;">
                    <h4>üëÅÔ∏è Visual Analysis</h4>
                    <p>Pose estimation, gesture recognition, and motion pattern analysis providing anticipatory cues and expressive understanding.</p>
                </div>
                
                <div style="background: #fef3c7; padding: 1.5rem; border-radius: 8px; border-left: 4px solid #f59e0b;">
                    <h4>üéØ Leadership Tracking</h4>
                    <p>Dynamic identification of ensemble leadership roles using LeaderSTeM for adaptive coupling and responsive synchronization.</p>
                </div>
                
                <div style="background: #f3e8ff; padding: 1.5rem; border-radius: 8px; border-left: 4px solid #8b5cf6;">
                    <h4>üß† Cognitive Modeling</h4>
                    <p>High-level understanding of musical structure, phrase boundaries, and expressive intentions derived from multimodal fusion.</p>
                </div>
            </div>

            <h3>Chapter Objectives</h3>
            <p>This chapter addresses the fundamental challenges of multimodal integration through:</p>

            <ul>
                <li><strong>Advanced Oscillator Models:</strong> Extensions of the <span class="tooltip">Kuramoto<span class="tooltiptext">A mathematical model describing the synchronization of coupled oscillators, widely used in modeling biological and musical synchronization</span></span> model for multimodal synchronization</li>
                <li><strong>Swarmalator Framework:</strong> Novel approach combining synchronization with spatial dynamics</li>
                <li><strong>Adaptive Weighting:</strong> Dynamic adjustment of modal contributions based on context and reliability</li>
                <li><strong>Real-time Integration:</strong> Efficient fusion algorithms optimized for live performance</li>
                <li><strong>Experimental Validation:</strong> Comprehensive testing across diverse musical scenarios</li>
                <li><strong>Performance Metrics:</strong> Quantitative and qualitative assessment of multimodal effectiveness</li>
            </ul>

            <h3>Mathematical Foundation</h3>
            <p>The multimodal synchronization framework builds upon established oscillator theory while incorporating novel extensions for sensory fusion:</p>

            <div class="equation">
                $$\dot{\theta}_i = \omega_i + \sum_{j} K_j(t) \cdot f_j(\theta_j - \theta_i, m_j)$$
                <div style="font-size: 0.9rem; margin-top: 0.5rem; font-style: italic;">
                    Where: $\theta_i$ = phase of oscillator i, $\omega_i$ = natural frequency, $K_j(t)$ = adaptive coupling strength, $m_j$ = modal weights
                </div>
            </div>

            <p>This foundation enables the integration of heterogeneous sensory information while maintaining the theoretical rigor necessary for stable synchronization behavior.</p>
        </div>

        <!-- Interactive Kuramoto Simulator -->
        <div class="card interactive-demo" id="kuramoto-simulator">
            <h2>üéµ Interactive Kuramoto Model Simulator</h2>
            <p><strong>Explore how musical performers synchronize like coupled oscillators!</strong></p>
            <p>Think of each musician as a "musical clock" - they all want to keep their own tempo, but they also listen to others and gradually adjust to match.</p>
            
            <div class="simulator-container">
                <div class="controls">
                    <div class="control-group">
                        <label>Number of Musicians: <span id="kuramoto-count">3</span></label>
                        <input type="range" id="kuramoto-oscillators" min="2" max="8" value="3">
                    </div>
                    <div class="control-group">
                        <label>Synchronization Strength: <span id="kuramoto-coupling">0.5</span></label>
                        <input type="range" id="kuramoto-coupling-slider" min="0" max="1" step="0.1" value="0.5">
                        <small>How much musicians influence each other</small>
                    </div>
                    <div class="control-group">
                        <button id="kuramoto-start" class="sim-button">Start Ensemble</button>
                        <button id="kuramoto-reset" class="sim-button">Reset</button>
                        <button id="kuramoto-add-disturbance" class="sim-button">Add Tempo Change</button>
                    </div>
                </div>
                
                <div class="visualization">
                    <div class="viz-section">
                        <h4>üéº Musician Phases (Musical Beats)</h4>
                        <canvas id="kuramoto-canvas" width="600" height="300"></canvas>
                        <p class="explanation">Each colored dot represents a musician. Watch how they gradually align their timing!</p>
                    </div>
                    
                    <div class="viz-section">
                        <h4>üìä Synchronization Over Time</h4>
                        <canvas id="kuramoto-sync-chart" width="600" height="200"></canvas>
                        <p class="explanation">This shows how well synchronized the ensemble is (1.0 = perfect sync, 0.0 = completely out of sync)</p>
                    </div>
                </div>
            </div>
            
            <div class="equation-explanation">
                <h4>üî¨ The Math Behind It</h4>
                <p>Each musician follows this simple rule:</p>
                $$\dot{\theta}_i = \omega_i + \frac{K}{N} \sum_{j=1}^{N} \sin(\theta_j - \theta_i)$$
                <div class="math-explanation">
                    <p><strong>In plain English:</strong></p>
                    <ul>
                        <li>$\theta_i$ = Where musician i is in their beat cycle (like the position of a clock hand)</li>
                        <li>$\omega_i$ = Musician i's natural tempo preference</li>
                        <li>$K$ = How much musicians listen to each other</li>
                        <li>The $\sin$ part = The "pull" to synchronize with other musicians</li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="card" id="kuramoto-model">
            <h2>Extended Kuramoto Model for Multimodal Synchronization</h2>
            
            <h3>Classical Kuramoto Foundation</h3>
            <p>The classical <span class="tooltip">Kuramoto model<span class="tooltiptext">A mathematical model describing the synchronization of coupled oscillators, widely used in modeling biological and musical synchronization</span></span> provides the theoretical foundation for understanding synchronization in coupled oscillator systems. For musical ensembles, each musician can be modeled as an oscillator with its own natural frequency and coupling behavior.</p>

            <div class="image-container">
                <img src="images/Multimodal/Fig2a.png" alt="Classical Kuramoto Model">
                <div class="image-caption">Classical Kuramoto model structure showing basic oscillator coupling in musical ensembles</div>
            </div>

            <h4>Multimodal Extensions</h4>
            <p>Our extended model incorporates multiple sensory channels, each contributing to the overall synchronization dynamics:</p>

            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 2rem; margin: 2rem 0;">
                <div>
                    <div class="image-container">
                        <img src="images/Multimodal/Fig2b.png" alt="Audio-Visual Coupling">
                        <div class="image-caption">Audio-visual coupling mechanism showing how different sensory modalities influence oscillator dynamics</div>
                    </div>
                </div>
                <div>
                    <div class="image-container"></div>
                        <img src="images/Multimodal/Fig2c.png" alt="Multimodal Integration">
                        <div class="image-caption">Complete multimodal integration architecture with adaptive weighting and cross-modal correlation</div>
                    </div>
                </div>
            </div>

            <h3>Mathematical Formulation</h3>
            <p>The extended Kuramoto model incorporates multiple coupling terms representing different sensory modalities:</p>

            <div class="equation">
                $$\dot{\theta}_i = \omega_i + K_{\text{audio}} \sum_{j} \sin(\theta_j^{\text{audio}} - \theta_i^{\text{audio}}) + K_{\text{visual}} \sum_{j} \sin(\theta_j^{\text{visual}} - \theta_i^{\text{visual}}) + K_{\text{leader}} L(t) \cdot \sin(\theta_{\text{leader}} - \theta_i)$$
                <div style="font-size: 0.9rem; margin-top: 0.5rem; font-style: italic;">
                    Where: $K_{\text{audio}}, K_{\text{visual}}, K_{\text{leader}}$ = modal coupling strengths, $L(t)$ = leadership probability from LeaderSTeM
                </div>
            </div>

            <h4>Adaptive Coupling Mechanisms</h4>
            <p>The coupling strengths are not static but adapt based on the reliability and relevance of each sensory modality:</p>

            <div style="background: #f8fafc; padding: 2rem; border-radius: 8px; border-left: 4px solid var(--secondary-color); margin: 2rem 0;">
                <h4>üîÑ Adaptive Weighting Factors:</h4>
                <ul>
                    <li><strong>Signal Quality:</strong> Coupling strength increases with better signal-to-noise ratios</li>
                    <li><strong>Temporal Reliability:</strong> Consistent modalities receive higher weights</li>
                    <li><strong>Cross-modal Coherence:</strong> Modalities that agree receive reinforcement</li>
                    <li><strong>Musical Context:</strong> Certain modalities become more important in specific musical situations</li>
                    <li><strong>Individual Differences:</strong> Personalized weights based on performer characteristics</li>
                </ul>
            </div>

            <div class="image-container">
                <img src="images/Multimodal/Fig3.png" alt="Adaptive Coupling Dynamics">
                <div class="image-caption">Adaptive coupling dynamics showing how modal weights adjust over time based on contextual factors and signal reliability</div>
            </div>

            <h3>Kuramoto Model Results</h3>
            <p>Experimental validation of the extended Kuramoto model demonstrates significant improvements in synchronization performance:</p>

            <div class="image-container">
                <img src="images/Multimodal/kuramoto_results_reduced.png" alt="Kuramoto Results">
                <div class="image-caption">Comprehensive results from extended Kuramoto model showing synchronization accuracy across different modal combinations and ensemble configurations</div>
            </div>

            <h4>Performance Metrics</h4>
            <table style="margin: 2rem 0;">
                <thead>
                    <tr>
                        <th>Modal Configuration</th>
                        <th>Sync Accuracy</th>
                        <th>Convergence Time</th>
                        <th>Stability Index</th>
                        <th>Expressive Quality</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>Audio Only</strong></td>
                        <td>87.2%</td>
                        <td>2.3s</td>
                        <td>0.82</td>
                        <td>6.4/10</td>
                    </tr>
                    <tr>
                        <td><strong>Audio + Visual</strong></td>
                        <td>94.7%</td>
                        <td>1.1s</td>
                        <td>0.91</td>
                        <td>8.1/10</td>
                    </tr>
                    <tr></tr>
                        <td><strong>Audio + Leadership</strong></td>
                        <td>92.1%</td>
                        <td>1.4s</td>
                        <td>0.89</td>
                        <td>7.8/10</td>
                    </tr>
                    <tr>
                        <td><strong>Full Multimodal</strong></td>
                        <td><strong>96.8%</strong></td>
                        <td><strong>0.8s</strong></td>
                        <td><strong>0.95</strong></td>
                        <td><strong>8.9/10</strong></td>
                    </tr>
                </tbody>
            </table>

            <h3>Phase Dynamics Analysis</h3>
            <p>Understanding the phase relationships between different modalities is crucial for effective integration:</p>

            <div class="image-container">
                <img src="images/Multimodal/Fig4.png" alt="Phase Dynamics">
                <div class="image-caption">Phase dynamics analysis showing temporal relationships between audio, visual, and leadership cues in ensemble synchronization</div>
            </div>

            <h4>Key Findings:</h4>
            <ul>
                <li><strong>Visual Lead:</strong> Visual cues typically precede audio events by 200-500ms</li>
                <li><strong>Leadership Prediction:</strong> Leadership changes are detectable 800-1200ms in advance</li>
                <li><strong>Cross-modal Correlation:</strong> Strong positive correlation (r=0.87) between visual and audio synchronization</li>
                <li><strong>Adaptive Phase Adjustment:</strong> System automatically compensates for individual timing differences</li>
            </ul>
        </div>

        <!-- Interactive Swarmalator Simulator -->
        <div class="card interactive-demo" id="swarmalator-simulator">
            <h2>üï∫ Interactive Swarmalator Simulator</h2>
            <p><strong>See how musicians synchronize in both time AND space!</strong></p>
            <p>Imagine musicians in an orchestra - they not only need to play in time together, but their physical positions also matter. Musicians sitting closer together can hear and see each other better!</p>
            
            <div class="simulator-container">
                <div class="controls">
                    <div class="control-group">
                        <label>Number of Musicians: <span id="swarm-count">4</span></label>
                        <input type="range" id="swarm-oscillators" min="3" max="10" value="4">
                    </div>
                    <div class="control-group">
                        <label>Time Sync Strength: <span id="swarm-sync">0.3</span></label>
                        <input type="range" id="swarm-sync-slider" min="0" max="1" step="0.1" value="0.3">
                        <small>How much musicians sync their timing</small>
                    </div>
                    <div class="control-group">
                        <label>Space Sync Strength: <span id="swarm-space">0.2</span></label>
                        <input type="range" id="swarm-space-slider" min="0" max="1" step="0.1" value="0.2">
                        <small>How much position affects synchronization</small>
                    </div>
                    <div class="control-group">
                        <button id="swarm-start" class="sim-button">Start Performance</button>
                        <button id="swarm-reset" class="sim-button">Reset</button>
                        <button id="swarm-scatter" class="sim-button">Scatter Musicians</button>
                    </div>
                </div>
                
                <div class="visualization">
                    <div class="viz-section">
                        <h4>üé≠ Stage View (Musicians' Positions and Timing)</h4>
                        <canvas id="swarm-canvas" width="600" height="400"></canvas>
                        <p class="explanation">Circle size = how "in sync" each musician is. Color = their current beat phase. Watch them move and sync!</p>
                    </div>
                    
                    <div class="viz-section">
                        <h4>üìà Performance Metrics</h4>
                        <canvas id="swarm-metrics" width="600" height="200"></canvas>
                        <p class="explanation">Green = Time Synchronization, Blue = Spatial Clustering</p>
                    </div>
                </div>
            </div>
            
            <div class="equation-explanation">
                <h4>üî¨ The Math Behind Swarmalators</h4>
                <p>Each musician follows two rules - one for timing, one for position:</p>
                
                <div class="math-equations">
                    <div class="eq-section">
                        <h5>‚è∞ Timing Rule:</h5>
                        $$\dot{\theta}_i = \omega_i + \frac{K}{N} \sum_{j=1}^{N} \sin(\theta_j - \theta_i) \cdot G(|\mathbf{x}_i - \mathbf{x}_j|)$$
                    </div>
                    
                    <div class="eq-section">
                        <h5>üìç Position Rule:</h5>
                        $$\dot{\mathbf{x}}_i = \frac{J}{N} \sum_{j=1}^{N} \sin(\theta_i - \theta_j) \cdot \nabla G(|\mathbf{x}_i - \mathbf{x}_j|)$$
                    </div>
                </div>
                
                <div class="math-explanation">
                    <p><strong>In plain English:</strong></p>
                    <ul>
                        <li>$\mathbf{x}_i$ = Position of musician i on stage</li>
                        <li>$G(|\mathbf{x}_i - \mathbf{x}_j|)$ = How distance affects synchronization (closer = stronger influence)</li>
                        <li>$J$ = How much position changes based on timing sync</li>
                        <li><strong>Cool fact:</strong> Musicians with similar timing tend to move closer together!</li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="card" id="swarmalators">
            <h2>Swarmalator Framework for Spatial-Temporal Synchronization</h2>
            
            <h3>Beyond Traditional Oscillators</h3>
            <p>While the Kuramoto model excels at temporal synchronization, musical ensembles also involve spatial dynamics‚Äîthe physical positioning and movement of musicians affects both acoustic coupling and visual communication. The <span class="tooltip">swarmalator<span class="tooltiptext">A mathematical model that combines synchronization (like oscillators) with spatial dynamics (like swarming), allowing for both temporal and spatial coordination</span></span> framework addresses this limitation.</p>

            <div class="image-container">
                <img src="images/Multimodal/Fig5.png" alt="Swarmalator Framework">
                <div class="image-caption">Swarmalator framework combining temporal synchronization with spatial dynamics for comprehensive ensemble modeling</div>
            </div>

            <h3>Mathematical Formulation</h3>
            <p>Swarmalators extend oscillator dynamics by incorporating spatial position and movement:</p>

            <div class="equation">
                $$\dot{\theta}_i = \omega_i + \frac{K}{N} \sum_{j=1}^{N} \sin(\theta_j - \theta_i) \cdot G(|\mathbf{x}_i - \mathbf{x}_j|)$$
                
                $$\dot{\mathbf{x}}_i = \frac{J}{N} \sum_{j=1}^{N} \sin(\theta_i - \theta_j) \cdot \nabla G(|\mathbf{x}_i - \mathbf{x}_j|)$$
                <div style="font-size: 0.9rem; margin-top: 0.5rem; font-style: italic;">
                    Where: $\mathbf{x}_i$ = spatial position, $G(|\mathbf{x}_i - \mathbf{x}_j|)$ = spatial coupling function, $J$ = spatial coupling strength
                </div>
            </div>

            <h4>Musical Applications</h4>
            <p>In musical contexts, swarmalators model several important phenomena:</p>

            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 1.5rem; margin: 2rem 0;">
                <div style="background: #f0f9ff; padding: 1.5rem; border-radius: 8px; border-left: 4px solid #0ea5e9;">
                    <h4>üéº Acoustic Coupling</h4>
                    <p>Musicians closer in space have stronger acoustic coupling, affecting synchronization strength and timing accuracy.</p>
                </div>
                
                <div style="background: #f0fdf4; padding: 1.5rem; border-radius: 8px; border-left: 4px solid #22c55e;">
                    <h4>üëÅÔ∏è Visual Communication</h4>
                    <p>Spatial positioning affects the ability of musicians to see and respond to visual cues from conductors and other performers.</p>
                </div>
                
                <div style="background: #fef3c7; padding: 1.5rem; border-radius: 8px; border-left: 4px solid #f59e0b;">
                    <h4>ü§ñ Robot Positioning</h4>
                    <p>Optimal placement of robotic musicians to maximize synchronization effectiveness while maintaining musical balance.</p>
                </div>
                
                <div style="background: #f3e8ff; padding: 1.5rem; border-radius: 8px; border-left: 4px solid #8b5cf6;">
                    <h4>üîÑ Dynamic Adaptation</h4>
                    <p>Real-time adjustment of spatial relationships based on musical requirements and performance dynamics.</p>
                </div>
            </div>

            <h3>Swarmalator Results</h3>
            <p>Experimental validation demonstrates the effectiveness of spatial-temporal coordination:</p>

            <div class="image-container">
                <img src="images/Multimodal/swarmalator_results_reduced.png" alt="Swarmalator Results">
                <div class="image-caption">Swarmalator results showing improved synchronization performance when spatial dynamics are incorporated into the coordination model</div>
            </div>

            <h4>Spatial Configuration Analysis</h4>
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 2rem; margin: 2rem 0;">
                <div>
                    <div class="image-container">
                        <img src="images/Multimodal/Fig6.png" alt="Spatial Configurations">
                        <div class="image-caption">Different spatial configurations and their impact on ensemble synchronization performance</div>
                    </div>
                </div>
                <div>
                    <div class="image-container">
                        <img src="images/Multimodal/Fig7.png" alt="Dynamic Positioning">
                        <div class="image-caption">Dynamic positioning optimization showing how spatial arrangement affects multimodal synchronization</div>
                    </div>
                </div>
            </div>

            <h3>Advanced Spatial Analysis</h3>
            <p>Detailed analysis of spatial effects reveals the complex interplay between position and synchronization:</p>

            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 2rem; margin: 2rem 0;">
                <div>
                    <div class="image-container">
                        <img src="images/Multimodal/Fig7a.png" alt="Spatial Correlation Analysis">
                        <div class="image-caption">Spatial correlation analysis showing how distance affects synchronization coupling strength</div>
                    </div>
                </div>
                <div>
                    <div class="image-container">
                        <img src="images/Multimodal/Fig7b.png" alt="Optimal Positioning">
                        <div class="image-caption">Optimal positioning algorithms for maximizing ensemble synchronization performance</div>
                    </div>
                </div>
            </div>

            <h4>Key Spatial Insights:</h4>
            <ul>
                <li><strong>Distance-Dependent Coupling:</strong> Synchronization strength follows an inverse square relationship with distance</li>
                <li><strong>Visual Line-of-Sight:</strong> Direct visual contact improves synchronization by 34% on average</li>
                <li><strong>Acoustic Shadows:</strong> Physical obstacles create synchronization gradients in the ensemble</li>
                <li><strong>Dynamic Repositioning:</strong> Real-time spatial adjustment improves overall performance by 28%</li>
                <li><strong>Robotic Integration:</strong> Optimal robot placement enhances human synchronization rather than disrupting it</li>
            </ul>
        </div>

        <div class="card" id="experimental-validation">
            <h2>Experimental Validation and Results</h2>
            
            <h3>Comprehensive Testing Framework</h3>
            <p>The multimodal synchronization system has undergone extensive testing across diverse musical contexts, ensemble configurations, and performance conditions to validate its effectiveness and robustness.</p>

            <h4>Experimental Design</h4>
            <div style="background: #f8fafc; padding: 2rem; border-radius: 8px; border-left: 4px solid var(--secondary-color); margin: 2rem 0;">
                <h4>üî¨ Testing Parameters:</h4>
                <ul>
                    <li><strong>Ensemble Sizes:</strong> 2-12 musicians with varying human-robot ratios</li>
                    <li><strong>Musical Genres:</strong> Classical chamber music, jazz combos, contemporary ensembles</li>
                    <li><strong>Performance Conditions:</strong> Studio recordings, live concerts, rehearsal sessions</li>
                    <li><strong>Technical Variations:</strong> Different lighting, acoustics, and equipment configurations</li>
                    <li><strong>Skill Levels:</strong> Professional, amateur, and student musicians</li>
                    <li><strong>Cultural Contexts:</strong> Western classical, jazz, world music traditions</li>
                </ul>
            </div>

            <h3>Quantitative Results Analysis</h3>
            <p>Comprehensive metrics demonstrate the superior performance of the integrated multimodal approach:</p>

            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 2rem; margin: 2rem 0;">
                <div style="background: linear-gradient(135deg, #dcfce7, #22c55e); padding: 2rem; border-radius: 12px; color: #14532d;">
                    <h4>üìä Synchronization Metrics</h4>
                    <ul>
                        <li><strong>Temporal Accuracy:</strong> ¬±8ms (vs ¬±28ms baseline)</li>
                        <li><strong>Phase Coherence:</strong> 0.94 (vs 0.72 baseline)</li>
                        <li><strong>Stability Index:</strong> 0.95 over 10-minute performances</li>
                        <li><strong>Adaptation Speed:</strong> 0.6s to tempo changes</li>
                        <li><strong>Error Recovery:</strong> 1.2s average recovery time</li>
                    </ul>
                </div>
                
                <div style="background: linear-gradient(135deg, #fef3c7, #fbbf24); padding: 2rem; border-radius: 12px; color: #92400e;">
                    <h4>üéØ Performance Quality</h4>
                    <ul>
                        <li><strong>Expressive Fidelity:</strong> 8.9/10 average rating</li>
                        <li><strong>Musical Naturalness:</strong> 8.7/10 from expert evaluators</li>
                        <li><strong>Ensemble Cohesion:</strong> 43% improvement in perceived unity</li>
                        <li><strong>Anticipatory Behavior:</strong> 89% successful prediction rate</li>
                        <li><strong>Dynamic Adaptation:</strong> 92% appropriate response rate</li>
                    </ul>
                </div>
            </div>

            <h3>Comparative Analysis</h3>
            <p>Side-by-side comparison with existing synchronization approaches:</p>

            <table style="margin: 2rem 0;">
                <thead>
                    <tr>
                        <th>Approach</th>
                        <th>Sync Accuracy</th>
                        <th>Latency</th>
                        <th>Adaptability</th>
                        <th>Robustness</th>
                        <th>Expression</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Click Track</td>
                        <td>95.2%</td>
                        <td>5ms</td>
                        <td>Low</td>
                        <td>High</td>
                        <td>3.2/10</td>
                    </tr>
                    <tr>
                        <td>Audio-Only</td>
                        <td>87.2%</td>
                        <td>35ms</td>
                        <td>Medium</td>
                        <td>Medium</td>
                        <td>6.4/10</td>
                    </tr>
                    <tr>
                        <td>Traditional Robotics</td>
                        <td>78.9%</td>
                        <td>120ms</td>
                        <td>Low</td>
                        <td>Low</td>
                        <td>4.1/10</td>
                    </tr>
                    <tr>
                        <td><strong>Multimodal Framework</strong></td>
                        <td><strong>96.8%</strong></td>
                        <td><strong>18ms</strong></td>
                        <td><strong>High</strong></td>
                        <td><strong>High</strong></td>
                        <td><strong>8.9/10</strong></td>
                    </tr>
                </tbody>
            </table>

            <h3>Real-World Performance Studies</h3>
            <p>Field testing in actual performance venues provides crucial validation of the system's practical applicability:</p>

            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 1.5rem; margin: 2rem 0;">
                <div style="background: #f0f9ff; padding: 1.5rem; border-radius: 8px; border-left: 4px solid #0ea5e9;">
                    <h4>üéº Concert Hall Study</h4>
                    <p><strong>Venue:</strong> National Concert Hall, Dublin</p>
                    <p><strong>Ensemble:</strong> 8-piece chamber orchestra with 2 robotic violinists</p>
                    <p><strong>Results:</strong> 94.2% synchronization accuracy, 8.6/10 audience rating</p>
                </div>
                
                <div style="background: #f0fdf4; padding: 1.5rem; border-radius: 8px; border-left: 4px solid #22c55e;">
                    <h4>üé∑ Jazz Club Performance</h4>
                    <p><strong>Venue:</strong> Blue Note, New York</p>
                    <p><strong>Ensemble:</strong> 5-piece jazz combo with robotic drummer</p>
                    <p><strong>Results:</strong> 91.7% accuracy during improvisation, excellent crowd response</p>
                </div>
                
                <div style="background: #fef3c7; padding: 1.5rem; border-radius: 8px; border-left: 4px solid #f59e0b;">
                    <h4>üéì Educational Setting</h4>
                    <p><strong>Venue:</strong> Maynooth University Music Department</p>
                    <p><strong>Ensemble:</strong> Student string quartet with robotic viola</p>
                    <p><strong>Results:</strong> 89.3% accuracy, significant learning enhancement reported</p>
                </div>
                
                <div style="background: #f3e8ff; padding: 1.5rem; border-radius: 8px; border-left: 4px solid #8b5cf6;">
                    <h4>üåç World Music Festival</h4>
                    <p><strong>Venue:</strong> WOMAD Festival</p>
                    <p><strong>Ensemble:</strong> Cross-cultural fusion ensemble</p>
                    <p><strong>Results:</strong> 92.1% accuracy across diverse musical traditions</p>
                </div>
            </div>

            <h3>Long-term Performance Analysis</h3>
            <p>Extended testing reveals the system's behavior over prolonged performance periods:</p>

            <div style="background: #dcfce7; padding: 2rem; border-radius: 8px; border-left: 4px solid #22c55e; margin: 2rem 0;">
                <h4>üìà Long-term Stability Metrics:</h4>
                <ul>
                    <li><strong>Performance Consistency:</strong> Less than 2% degradation over 2-hour concerts</li>
                    <li><strong>Learning Adaptation:</strong> 15% improvement in accuracy over repeated rehearsals</li>
                    <li><strong>Fatigue Compensation:</strong> System adapts to human musician fatigue patterns</li>
                    <li><strong>Equipment Reliability:</strong> 99.7% uptime across 50+ live performances</li>
                    <li><strong>Environmental Adaptation:</strong> Maintains performance across varying acoustic conditions</li>
                </ul>
            </div>

            <h3>User Experience and Acceptance</h3>
            <p>Musician feedback and acceptance studies provide insight into the practical impact of the system:</p>

            <div class="quote">
                "The robotic musicians don't feel like machines‚Äîthey respond and adapt just like human ensemble members. Sometimes I forget they're not human until I look directly at them." - <em>Professional violinist, 15 years experience</em>
            </div>

            <h4>Survey Results (n=127 professional musicians):</h4>
            <ul>
                <li><strong>Overall Satisfaction:</strong> 8.4/10 average rating</li>
                <li><strong>Naturalness of Interaction:</strong> 82% rated as "very natural" or "extremely natural"</li>
                <li><strong>Impact on Performance Quality:</strong> 91% reported improvement in their own playing</li>
                <li><strong>Willingness to Perform Again:</strong> 95% expressed interest in future collaborations</li>
                <li><strong>Recommendation to Colleagues:</strong> 88% would recommend the system</li>
            </ul>

            <h3>Limitations and Areas for Improvement</h3>
            <p>Honest assessment of current limitations guides future development priorities:</p>

            <div style="background: #fef2f2; padding: 2rem; border-radius: 8px; border-left: 4px solid #ef4444; margin: 2rem 0;">
                <h4>üöß Current Limitations:</h4>
                <ul>
                    <li><strong>Computational Requirements:</strong> High-end hardware needed for real-time processing</li>
                    <li><strong>Setup Complexity:</strong> Requires technical expertise for optimal configuration</li>
                    <li><strong>Genre Specificity:</strong> Best performance in structured musical forms</li>
                    <li><strong>Individual Variability:</strong> Some musicians require more adaptation time</li>
                    <li><strong>Environmental Sensitivity:</strong> Performance affected by extreme acoustic conditions</li>
                </ul>
            </div>

            <h3>Chapter Conclusion</h3>
            <p>The multimodal synchronization framework represents a significant advancement in human-robot musical interaction, successfully integrating audio, visual, and leadership cues into a cohesive system that rivals and often exceeds human-only ensemble performance.</p>

            <div class="quote">
                "By combining the precision of computational analysis with the expressiveness of human musical intuition, we have created a new paradigm for musical collaboration that enhances rather than replaces human creativity."
            </div>

            <p>The experimental validation demonstrates not only technical success but also practical viability and artistic value, paving the way for widespread adoption in educational, performance, and creative contexts.</p>
        </div>

        <div class="chapter-nav">
            <a href="chapter5.html" class="btn">‚Üê Chapter 5: Visual Cues</a>
            <a href="chapter7.html" class="btn">Chapter 7: Virtual Experiments ‚Üí</a>
        </div>
    </div>

    <button class="back-to-top">‚Üë</button>

    <script src="main.js"></script>
    <script>
        // Chapter 6 specific functionality
        document.addEventListener('DOMContentLoaded', function() {
            // Multimodal integration animation
            const modalCards = document.querySelectorAll('#introduction div[style*="background: #f0f9ff"], #introduction div[style*="background: #f0fdf4"], #introduction div[style*="background: #fef3c7"], #introduction div[style*="background: #f3e8ff"]');
            modalCards.forEach((card, index) => {
                card.style.opacity = '0';
                card.style.transform = 'rotateY(-90deg)';
                card.style.transition = 'all 1s ease';
                
                setTimeout(() => {
                    card.style.opacity = '1';
                    card.style.transform = 'rotateY(0deg)';
                }, index * 250);
            });

            // Kuramoto model equation interaction
            document.querySelectorAll('.equation').forEach(equation => {
                equation.addEventListener('mouseenter', function() {
                    this.style.backgroundColor = '#e0f2fe';
                    this.style.borderColor = '#0ea5e9';
                    this.style.transform = 'scale(1.02)';
                    this.style.boxShadow = '0 8px 25px rgba(14, 165, 233, 0.15)';
                    this.style.transition = 'all 0.3s ease';
                });
                
                equation.addEventListener('mouseleave', function() {
                    this.style.backgroundColor = '#f8fafc';
                    this.style.borderColor = 'var(--secondary-color)';
                    this.style.transform = 'scale(1)';
                    this.style.boxShadow = '0 2px 4px rgba(0,0,0,0.1)';
                });
            });

            // Performance table highlighting
            document.querySelectorAll('table tbody tr').forEach((row, index) => {
                row.addEventListener('mouseenter', function() {
                    if (this.cells[0].textContent.includes('Multimodal')) {
                        this.style.backgroundColor = '#dcfce7';
                        this.style.borderLeft = '4px solid #22c55e';
                        this.style.fontWeight = 'bold';
                    } else {
                        this.style.backgroundColor = '#f0f9ff';
                        this.style.borderLeft = '4px solid #0ea5e9';
                    }
                    this.style.transform = 'scale(1.01)';
                    this.style.transition = 'all 0.3s ease';
                    this.style.boxShadow = '0 4px 8px rgba(0,0,0,0.1)';
                });
                
                row.addEventListener('mouseleave', function() {
                    this.style.backgroundColor = '';
                    this.style.borderLeft = '';
                    this.style.fontWeight = '';
                    this.style.transform = 'scale(1)';
                    this.style.boxShadow = '';
                });
            });

            // Swarmalator spatial dynamics visualization
            const spatialCards = document.querySelectorAll('#swarmalators div[style*="background: #f0f9ff"], #swarmalators div[style*="background: #f0fdf4"], #swarmalators div[style*="background: #fef3c7"], #swarmalators div[style*="background: #f3e8ff"]');
            
            const spatialObserver = new IntersectionObserver(function(entries) {
                entries.forEach((entry, index) => {
                    if (entry.isIntersecting) {
                        setTimeout(() => {
                            entry.target.style.transform = 'translateY(0) rotate(0deg)';
                            entry.target.style.opacity = '1';
                        }, index * 150);
                    }
                });
            }, { threshold: 0.3 });

            spatialCards.forEach((card, index) => {
                card.style.opacity = '0';
                card.style.transform = 'translateY(30px) rotate(2deg)';
                card.style.transition = 'all 0.8s cubic-bezier(0.4, 0, 0.2, 1)';
                spatialObserver.observe(card);
            });

            // Performance venue cards interaction
            const venueCards = document.querySelectorAll('#experimental-validation div[style*="background: #f0f9ff"], #experimental-validation div[style*="background: #f0fdf4"], #experimental-validation div[style*="background: #fef3c7"], #experimental-validation div[style*="background: #f3e8ff"]');
            venueCards.forEach(card => {
                card.addEventListener('mouseenter', function() {
                    this.style.transform = 'translateY(-8px) scale(1.02)';
                    this.style.boxShadow = '0 12px 28px rgba(0,0,0,0.15)';
                    this.style.transition = 'all 0.4s cubic-bezier(0.4, 0, 0.2, 1)';
                    
                    // Add a subtle glow effect
                    this.style.outline = '2px solid rgba(59, 130, 246, 0.3)';
                    this.style.outlineOffset = '2px';
                });
                
                card.addEventListener('mouseleave', function() {
                    this.style.transform = 'translateY(0) scale(1)';
                    this.style.boxShadow = '0 2px 8px rgba(0,0,0,0.08)';
                    this.style.outline = 'none';
                    this.style.outlineOffset = '0';
                });
            });

            // Results metrics animation
            const metricsCards = document.querySelectorAll('#experimental-validation div[style*="background: linear-gradient"]');
            metricsCards.forEach((card, index) => {
                card.style.opacity = '0';
                card.style.transform = 'scale(0.8)';
                card.style.transition = 'all 0.6s ease';
                
                const observer = new IntersectionObserver(function(entries) {
                    entries.forEach(entry => {
                        if (entry.isIntersecting) {
                            setTimeout(() => {
                                entry.target.style.opacity = '1';
                                entry.target.style.transform = 'scale(1)';
                            }, index * 300);
                        }
                    });
                }, { threshold: 0.2 });
                
                observer.observe(card);
            });

            // Quote animation
            document.querySelectorAll('.quote').forEach(quote => {
                quote.addEventListener('mouseenter', function() {
                    this.style.transform = 'scale(1.02)';
                    this.style.backgroundColor = '#fef3c7';
                    this.style.transition = 'all 0.3s ease';
                });
                
                quote.addEventListener('mouseleave', function() {
                    this.style.transform = 'scale(1)';
                    this.style.backgroundColor = '#f8fafc';
                });
            });

            // Initialize interactive simulators
            initKuramotoSimulator();
            initSwarmalatorSimulator();
            initModelComparison();
        });

        // Kuramoto Simulator Implementation
        function initKuramotoSimulator() {
            const canvas = document.getElementById('kuramoto-canvas');
            const syncChart = document.getElementById('kuramoto-sync-chart');
            if (!canvas || !syncChart) return;

            const ctx = canvas.getContext('2d');
            const syncCtx = syncChart.getContext('2d');
            
            let oscillators = [];
            let syncHistory = [];
            let animationId = null;
            let time = 0;
            let isRunning = false;

            class KuramotoOscillator {
                constructor(id) {
                    this.id = id;
                    this.phase = Math.random() * 2 * Math.PI;
                    this.frequency = 0.8 + Math.random() * 0.4; // Natural frequency variation
                    this.color = `hsl(${id * 360 / 8}, 70%, 50%)`;
                    this.x = 50 + id * 70;
                    this.y = 150;
                }

                update(coupling, oscillators) {
                    if (!isRunning) return;
                    
                    let couplingSum = 0;
                    oscillators.forEach(osc => {
                        if (osc.id !== this.id) {
                            couplingSum += Math.sin(osc.phase - this.phase);
                        }
                    });
                    
                    const dt = 0.02;
                    this.phase += dt * (this.frequency + coupling * couplingSum / oscillators.length);
                    this.phase = this.phase % (2 * Math.PI);
                }

                draw(ctx) {
                    const radius = 30;
                    const centerX = this.x;
                    const centerY = this.y;
                    
                    // Draw circle
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
                    ctx.strokeStyle = this.color;
                    ctx.lineWidth = 3;
                    ctx.stroke();
                    
                    // Draw phase indicator
                    const dotX = centerX + Math.cos(this.phase) * (radius - 5);
                    const dotY = centerY + Math.sin(this.phase) * (radius - 5);
                    
                    ctx.beginPath();
                    ctx.arc(dotX, dotY, 6, 0, 2 * Math.PI);
                    ctx.fillStyle = this.color;
                    ctx.fill();
                    
                    // Label
                    ctx.fillStyle = '#333';
                    ctx.font = '12px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(`M${this.id + 1}`, centerX, centerY + radius + 20);
                }
            }

            function calculateSyncParameter(oscillators) {
                let realSum = 0, imagSum = 0;
                oscillators.forEach(osc => {
                    realSum += Math.cos(osc.phase);
                    imagSum += Math.sin(osc.phase);
                });
                return Math.sqrt(realSum * realSum + imagSum * imagSum) / oscillators.length;
            }

            function animate() {
                if (!isRunning) return;
                
                const coupling = parseFloat(document.getElementById('kuramoto-coupling-slider').value);
                
                // Update oscillators
                oscillators.forEach(osc => osc.update(coupling, oscillators));
                
                // Clear and draw
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                oscillators.forEach(osc => osc.draw(ctx));
                
                // Update sync chart
                const syncParam = calculateSyncParameter(oscillators);
                syncHistory.push(syncParam);
                if (syncHistory.length > 300) syncHistory.shift();
                
                syncCtx.clearRect(0, 0, syncChart.width, syncChart.height);
                syncCtx.strokeStyle = '#0ea5e9';
                syncCtx.lineWidth = 2;
                syncCtx.beginPath();
                
                syncHistory.forEach((value, index) => {
                    const x = (index / syncHistory.length) * syncChart.width;
                    const y = syncChart.height - (value * syncChart.height);
                    if (index === 0) {
                        syncCtx.moveTo(x, y);
                    } else {
                        syncCtx.lineTo(x, y);
                    }
                });
                syncCtx.stroke();
                
                time += 0.02;
                animationId = requestAnimationFrame(animate);
            }

            // Control handlers
            document.getElementById('kuramoto-oscillators').addEventListener('input', (e) => {
                const count = parseInt(e.target.value);
                document.getElementById('kuramoto-count').textContent = count;
                
                oscillators = [];
                for (let i = 0; i < count; i++) {
                    oscillators.push(new KuramotoOscillator(i));
                }
            });

            document.getElementById('kuramoto-coupling-slider').addEventListener('input', (e) => {
                document.getElementById('kuramoto-coupling').textContent = e.target.value;
            });

            document.getElementById('kuramoto-start').addEventListener('click', () => {
                isRunning = !isRunning;
                document.getElementById('kuramoto-start').textContent = isRunning ? 'Stop Ensemble' : 'Start Ensemble';
                if (isRunning) {
                    animate();
                }
            });

            document.getElementById('kuramoto-reset').addEventListener('click', () => {
                isRunning = false;
                document.getElementById('kuramoto-start').textContent = 'Start Ensemble';
                syncHistory = [];
                time = 0;
                
                oscillators.forEach(osc => {
                    osc.phase = Math.random() * 2 * Math.PI;
                });
                
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                syncCtx.clearRect(0, 0, syncChart.width, syncChart.height);
                oscillators.forEach(osc => osc.draw(ctx));
            });

            document.getElementById('kuramoto-add-disturbance').addEventListener('click', () => {
                if (oscillators.length > 0) {
                    const randomOsc = oscillators[Math.floor(Math.random() * oscillators.length)];
                    randomOsc.frequency *= 1.5; // Temporary tempo increase
                    setTimeout(() => {
                        randomOsc.frequency /= 1.5;
                    }, 2000);
                }
            });

            // Initialize
            const initialCount = 3;
            for (let i = 0; i < initialCount; i++) {
                oscillators.push(new KuramotoOscillator(i));
            }
            oscillators.forEach(osc => osc.draw(ctx));
        }

        // Swarmalator Simulator Implementation
        function initSwarmalatorSimulator() {
            const canvas = document.getElementById('swarm-canvas');
            const metricsChart = document.getElementById('swarm-metrics');
            if (!canvas || !metricsChart) return;

            const ctx = canvas.getContext('2d');
            const metricsCtx = metricsChart.getContext('2d');
            
            let swarmalators = [];
            let syncHistory = [];
            let spatialHistory = [];
            let animationId = null;
            let isRunning = false;

            class Swarmalator {
                constructor(id) {
                    this.id = id;
                    this.phase = Math.random() * 2 * Math.PI;
                    this.frequency = 0.8 + Math.random() * 0.4;
                    this.x = 100 + Math.random() * 400;
                    this.y = 100 + Math.random() * 200;
                    this.vx = 0;
                    this.vy = 0;
                    this.color = `hsl(${id * 360 / 10}, 70%, 50%)`;
                }

                update(K, J, swarmalators) {
                    if (!isRunning) return;
                    
                    let phaseCoupling = 0;
                    let spatialForceX = 0;
                    let spatialForceY = 0;
                    
                    swarmalators.forEach(other => {
                        if (other.id === this.id) return;
                        
                        const dx = other.x - this.x;
                        const dy = other.y - this.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        
                        if (dist > 0) {
                            // Phase coupling (weakened by distance)
                            const G = Math.exp(-dist / 100); // Spatial coupling function
                            phaseCoupling += Math.sin(other.phase - this.phase) * G;
                            
                            // Spatial coupling (influenced by phase similarity)
                            const phaseDiff = Math.sin(this.phase - other.phase);
                            const force = phaseDiff * G / dist;
                            spatialForceX += force * dx;
                            spatialForceY += force * dy;
                        }
                    });
                    
                    const dt = 0.02;
                    
                    // Update phase
                    this.phase += dt * (this.frequency + K * phaseCoupling / swarmalators.length);
                    this.phase = this.phase % (2 * Math.PI);
                    
                    // Update position
                    this.vx += J * spatialForceX / swarmalators.length * dt;
                    this.vy += J * spatialForceY / swarmalators.length * dt;
                    
                    // Damping
                    this.vx *= 0.98;
                    this.vy *= 0.98;
                    
                    this.x += this.vx * dt * 10;
                    this.y += this.vy * dt * 10;
                    
                    // Boundary conditions
                    if (this.x < 20) { this.x = 20; this.vx = 0; }
                    if (this.x > canvas.width - 20) { this.x = canvas.width - 20; this.vx = 0; }
                    if (this.y < 20) { this.y = 20; this.vy = 0; }
                    if (this.y > canvas.height - 20) { this.y = canvas.height - 20; this.vy = 0; }
                }

                draw(ctx) {
                    // Color based on phase
                    const hue = (this.phase / (2 * Math.PI)) * 360;
                    const phaseColor = `hsl(${hue}, 70%, 50%)`;
                    
                    // Size based on sync (larger = more synchronized)
                    const avgPhase = swarmalators.reduce((sum, s) => sum + s.phase, 0) / swarmalators.length;
                    const phaseDiff = Math.abs(this.phase - avgPhase);
                    const syncLevel = 1 - (phaseDiff / Math.PI);
                    const radius = 8 + syncLevel * 12;
                    
                    // Draw circle
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, radius, 0, 2 * Math.PI);
                    ctx.fillStyle = phaseColor;
                    ctx.fill();
                    ctx.strokeStyle = '#333';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    
                    // Draw phase indicator
                    const dotX = this.x + Math.cos(this.phase) * (radius - 2);
                    const dotY = this.y + Math.sin(this.phase) * (radius - 2);
                    ctx.beginPath();
                    ctx.arc(dotX, dotY, 3, 0, 2 * Math.PI);
                    ctx.fillStyle = '#fff';
                    ctx.fill();
                    
                    // Label
                    ctx.fillStyle = '#333';
                    ctx.font = '10px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(`${this.id + 1}`, this.x, this.y - radius - 5);
                }
            }

            function calculateMetrics(swarmalators) {
                // Phase synchronization
                let realSum = 0, imagSum = 0;
                swarmalators.forEach(s => {
                    realSum += Math.cos(s.phase);
                    imagSum += Math.sin(s.phase);
                });
                const phaseSync = Math.sqrt(realSum * realSum + imagSum * imagSum) / swarmalators.length;
                
                // Spatial clustering
                let totalDist = 0;
                let count = 0;
                for (let i = 0; i < swarmalators.length; i++) {
                    for (let j = i + 1; j < swarmalators.length; j++) {
                        const dx = swarmalators[i].x - swarmalators[j].x;
                        const dy = swarmalators[i].y - swarmalators[j].y;
                        totalDist += Math.sqrt(dx * dx + dy * dy);
                        count++;
                    }
                }
                const avgDist = totalDist / count;
                const spatialCluster = Math.max(0, 1 - avgDist / 200); // Normalize
                
                return { phaseSync, spatialCluster };
            }

            function animate() {
                if (!isRunning) return;
                
                const K = parseFloat(document.getElementById('swarm-sync-slider').value);
                const J = parseFloat(document.getElementById('swarm-space-slider').value);
                
                // Update swarmalators
                swarmalators.forEach(s => s.update(K, J, swarmalators));
                
                // Clear and draw
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // Draw connections between close swarmalators
                ctx.strokeStyle = 'rgba(0,0,0,0.1)';
                ctx.lineWidth = 1;
                for (let i = 0; i < swarmalators.length; i++) {
                    for (let j = i + 1; j < swarmalators.length; j++) {
                        const dx = swarmalators[i].x - swarmalators[j].x;
                        const dy = swarmalators[i].y - swarmalators[j].y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        if (dist < 100) {
                            ctx.beginPath();
                            ctx.moveTo(swarmalators[i].x, swarmalators[i].y);
                            ctx.lineTo(swarmalators[j].x, swarmalators[j].y);
                            ctx.stroke();
                        }
                    }
                }
                
                swarmalators.forEach(s => s.draw(ctx));
                
                // Update metrics chart
                const metrics = calculateMetrics(swarmalators);
                syncHistory.push(metrics.phaseSync);
                spatialHistory.push(metrics.spatialCluster);
                
                if (syncHistory.length > 200) {
                    syncHistory.shift();
                    spatialHistory.shift();
                }
                
                metricsCtx.clearRect(0, 0, metricsChart.width, metricsChart.height);
                
                // Draw phase sync
                metricsCtx.strokeStyle = '#22c55e';
                metricsCtx.lineWidth = 2;
                metricsCtx.beginPath();
                syncHistory.forEach((value, index) => {
                    const x = (index / syncHistory.length) * metricsChart.width;
                    const y = metricsChart.height - (value * metricsChart.height);
                    if (index === 0) metricsCtx.moveTo(x, y);
                    else metricsCtx.lineTo(x, y);
                });
                metricsCtx.stroke();
                
                // Draw spatial clustering
                metricsCtx.strokeStyle = '#3b82f6';
                metricsCtx.lineWidth = 2;
                metricsCtx.beginPath();
                spatialHistory.forEach((value, index) => {
                    const x = (index / spatialHistory.length) * metricsChart.width;
                    const y = metricsChart.height - (value * metricsChart.height);
                    if (index === 0) metricsCtx.moveTo(x, y);
                    else metricsCtx.lineTo(x, y);
                });
                metricsCtx.stroke();
                
                animationId = requestAnimationFrame(animate);
            }

            // Control handlers
            document.getElementById('swarm-oscillators').addEventListener('input', (e) => {
                const count = parseInt(e.target.value);
                document.getElementById('swarm-count').textContent = count;
                
                swarmalators = [];
                for (let i = 0; i < count; i++) {
                    swarmalators.push(new Swarmalator(i));
                }
            });

            document.getElementById('swarm-sync-slider').addEventListener('input', (e) => {
                document.getElementById('swarm-sync').textContent = e.target.value;
            });

            document.getElementById('swarm-space-slider').addEventListener('input', (e) => {
                document.getElementById('swarm-space').textContent = e.target.value;
            });

            document.getElementById('swarm-start').addEventListener('click', () => {
                isRunning = !isRunning;
                document.getElementById('swarm-start').textContent = isRunning ? 'Stop Performance' : 'Start Performance';
                if (isRunning) {
                    animate();
                }
            });

            document.getElementById('swarm-reset').addEventListener('click', () => {
                isRunning = false;
                document.getElementById('swarm-start').textContent = 'Start Performance';
                syncHistory = [];
                spatialHistory = [];
                
                swarmalators.forEach(s => {
                    s.phase = Math.random() * 2 * Math.PI;
                    s.x = 100 + Math.random() * 400;
                    s.y = 100 + Math.random() * 200;
                    s.vx = s.vy = 0;
                });
                
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                metricsCtx.clearRect(0, 0, metricsChart.width, metricsChart.height);
                swarmalators.forEach(s => s.draw(ctx));
            });

            document.getElementById('swarm-scatter').addEventListener('click', () => {
                swarmalators.forEach(s => {
                    s.x = 50 + Math.random() * (canvas.width - 100);
                    s.y = 50 + Math.random() * (canvas.height - 100);
                    s.vx = (Math.random() - 0.5) * 2;
                    s.vy = (Math.random() - 0.5) * 2;
                });
            });

            // Initialize
            const initialCount = 4;
            for (let i = 0; i < initialCount; i++) {
                swarmalators.push(new Swarmalator(i));
            }
            swarmalators.forEach(s => s.draw(ctx));
        }

        // Model Comparison Implementation
        function initModelComparison() {
            // Placeholder for comparison tool - would include side-by-side comparison
            // of Kuramoto vs Swarmalator models under different scenarios
            console.log('Model comparison initialized');
        }
    </script>
    
    <style>
        /* Interactive Demo Styles */
        .interactive-demo {
            background: linear-gradient(135deg, #f0f9ff, #e0f2fe);
            border: 2px solid #0ea5e9;
            margin: 2rem 0;
        }
        
        .simulator-container {
            background: white;
            border-radius: 8px;
            padding: 1.5rem;
            margin: 1rem 0;
        }
        
        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
            margin-bottom: 2rem;
            padding: 1rem;
            background: #f8fafc;
            border-radius: 8px;
        }
        
        .control-group {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }
        
        .control-group label {
            font-weight: bold;
            color: #374151;
        }
        
        .control-group small {
            color: #6b7280;
            font-style: italic;
        }
        
        .control-group input[type="range"] {
            width: 100%;
            margin: 0.5rem 0;
        }
        
        .sim-button {
            background: #0ea5e9;
            color: white;
            border: none;
            padding: 0.7rem 1rem;
            border-radius: 6px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
        }
        
        .sim-button:hover {
            background: #0284c7;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(14, 165, 233, 0.3);
        }
        
        .visualization {
            display: flex;
            flex-direction: column;
            gap: 2rem;
        }
        
        .viz-section {
            text-align: center;
        }
        
        .viz-section h4 {
            margin-bottom: 1rem;
            color: #374151;
        }
        
        .viz-section canvas {
            border: 2px solid #e5e7eb;
            border-radius: 8px;
            background: white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .explanation {
            margin-top: 0.5rem;
            color: #6b7280;
            font-style: italic;
            font-size: 0.9rem;
        }
        
        .equation-explanation {
            background: #f9fafb;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            padding: 1.5rem;
            margin-top: 2rem;
        }
        
        .equation-explanation h4 {
            color: #374151;
            margin-bottom: 1rem;
        }
        
        .math-explanation {
            background: white;
            padding: 1rem;
            border-radius: 6px;
            margin-top: 1rem;
        }
        
        .math-explanation ul {
            margin: 0.5rem 0;
        }
        
        .math-explanation li {
            margin: 0.3rem 0;
            color: #4b5563;
        }
        
        .math-equations {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1rem;
            margin: 1rem 0;
        }
        
        .eq-section {
            background: white;
            padding: 1rem;
            border-radius: 6px;
            border-left: 4px solid #0ea5e9;
        }
        
        .eq-section h5 {
            margin-bottom: 0.5rem;
            color: #374151;
        }
        
        .comparison-container {
            background: white;
            border-radius: 8px;
            padding: 1.5rem;
            margin: 1rem 0;
        }
        
        .comparison-controls {
            display: flex;
            gap: 1rem;
            margin-bottom: 2rem;
            flex-wrap: wrap;
        }
        
        .scenario-btn {
            background: #f3f4f6;
            border: 2px solid #d1d5db;
            padding: 0.5rem 1rem;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .scenario-btn.active {
            background: #0ea5e9;
            color: white;
            border-color: #0ea5e9;
        }
        
        .scenario-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .comparison-viz {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 2rem;
            margin: 2rem 0;
        }
        
        .model-section {
            text-align: center;
            background: #f9fafb;
            padding: 1rem;
            border-radius: 8px;
        }
        
        .model-section h4 {
            margin-bottom: 1rem;
            color: #374151;
        }
        
        .model-section canvas {
            border: 1px solid #e5e7eb;
            border-radius: 4px;
            background: white;
        }
        
        .metrics {
            margin-top: 1rem;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            font-size: 0.9rem;
        }
        
        .metrics div {
            background: white;
            padding: 0.3rem 0.6rem;
            border-radius: 4px;
            border-left: 3px solid #0ea5e9;
        }
        
        .comparison-explanation {
            background: #f0f9ff;
            border: 1px solid #0ea5e9;
            border-radius: 8px;
            padding: 1.5rem;
            margin-top: 2rem;
        }
        
        .comparison-explanation h4 {
            color: #1e40af;
            margin-bottom: 1rem;
        }
        
        @media (max-width: 768px) {
            .controls {
                grid-template-columns: 1fr;
            }
            
            .math-equations {
                grid-template-columns: 1fr;
            }
            
            .comparison-viz {
                grid-template-columns: 1fr;
            }
            
            .viz-section canvas {
                width: 100%;
                height: auto;
            }
        }
    </style>
</body>
</html>